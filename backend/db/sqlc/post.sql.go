// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: post.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPost = `-- name: CreatePost :one
INSERT INTO posts (content, user_id)
    VALUES ($1, $2)
RETURNING
    id, created_at, content, user_id
`

type CreatePostParams struct {
	Content *string `json:"content"`
	UserID  int64   `json:"user_id"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (*Post, error) {
	row := q.db.QueryRow(ctx, createPost, arg.Content, arg.UserID)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Content,
		&i.UserID,
	)
	return &i, err
}

const deletePostByPostID = `-- name: DeletePostByPostID :exec
DELETE FROM posts p
WHERE p.id = $1
`

func (q *Queries) DeletePostByPostID(ctx context.Context, postID int64) error {
	_, err := q.db.Exec(ctx, deletePostByPostID, postID)
	return err
}

const getFeedPosts = `-- name: GetFeedPosts :many
WITH post_stats AS (
    SELECT
        p.id AS post_id,
        COUNT(DISTINCT pl.id) AS like_count,
        COUNT(DISTINCT c.id) AS comment_count,
        COALESCE(BOOL_OR(pl.user_id = $2), FALSE)::boolean AS has_liked,
        json_agg(DISTINCT pi.uid) FILTER (WHERE pi.uid IS NOT NULL) AS image_uids
    FROM
        posts p
        RIGHT JOIN followers f ON p.user_id = f.followee_id
            AND f.follower_id = $2
        LEFT JOIN post_likes pl ON p.id = pl.post_id
        LEFT JOIN comments c ON p.id = c.post_id
        LEFT JOIN post_images pi ON p.id = pi.post_id
    WHERE ($3::bigint = 0
        OR p.id < $3::bigint)
GROUP BY
    p.id
)
SELECT
    p.id AS post_id,
    p.user_id AS owner_id,
    p.created_at AS created_at,
    p.content AS content,
    ps.like_count,
    ps.comment_count,
    ps.has_liked,
    ps.image_uids,
    u.username AS owner_username,
    pr.name AS owner_name,
    pr.profile_image AS owner_profile_image
FROM
    posts p
    JOIN users u ON p.user_id = u.id
    JOIN profiles pr ON u.id = pr.user_id
    JOIN post_stats ps ON p.id = ps.post_id
ORDER BY
    p.id DESC
LIMIT $1
`

type GetFeedPostsParams struct {
	Limit      int32 `json:"limit"`
	MyUserID   int64 `json:"my_user_id"`
	LastPostID int64 `json:"last_post_id"`
}

type GetFeedPostsRow struct {
	PostID            int64              `json:"post_id"`
	OwnerID           int64              `json:"owner_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Content           *string            `json:"content"`
	LikeCount         int64              `json:"like_count"`
	CommentCount      int64              `json:"comment_count"`
	HasLiked          bool               `json:"has_liked"`
	ImageUids         []byte             `json:"image_uids"`
	OwnerUsername     string             `json:"owner_username"`
	OwnerName         string             `json:"owner_name"`
	OwnerProfileImage uuid.UUID          `json:"owner_profile_image"`
}

func (q *Queries) GetFeedPosts(ctx context.Context, arg GetFeedPostsParams) ([]*GetFeedPostsRow, error) {
	rows, err := q.db.Query(ctx, getFeedPosts, arg.Limit, arg.MyUserID, arg.LastPostID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetFeedPostsRow
	for rows.Next() {
		var i GetFeedPostsRow
		if err := rows.Scan(
			&i.PostID,
			&i.OwnerID,
			&i.CreatedAt,
			&i.Content,
			&i.LikeCount,
			&i.CommentCount,
			&i.HasLiked,
			&i.ImageUids,
			&i.OwnerUsername,
			&i.OwnerName,
			&i.OwnerProfileImage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaginatedPostsByUsername = `-- name: GetPaginatedPostsByUsername :many
WITH post_stats AS (
    SELECT
        p.id AS post_id,
        COUNT(DISTINCT pl.id) AS like_count,
        COUNT(DISTINCT c.id) AS comment_count,
        COALESCE(BOOL_OR(pl.user_id = $1), FALSE)::boolean AS has_liked,
        json_agg(DISTINCT pi.uid) FILTER (WHERE pi.uid IS NOT NULL) AS image_uids
    FROM
        posts p
        LEFT JOIN post_likes pl ON p.id = pl.post_id
        LEFT JOIN comments c ON p.id = c.post_id
        LEFT JOIN post_images pi ON p.id = pi.post_id
    WHERE
        p.user_id = (
            SELECT
                id
            FROM
                users u
            WHERE
                u.username = $3)
            AND ($4::bigint = 0
                OR p.id < $4::bigint)
        GROUP BY
            p.id
)
SELECT
    p.id AS post_id,
    p.user_id AS owner_id,
    p.created_at AS created_at,
    p.content AS content,
    ps.like_count,
    ps.comment_count,
    ps.has_liked,
    ps.image_uids,
    u.username AS owner_username,
    pr.name AS owner_name,
    pr.profile_image AS owner_profile_image,
    EXISTS (
        SELECT
            1
        FROM
            followers
        WHERE
            followee_id = p.user_id
            AND follower_id = $1) AS owner_is_following
FROM
    posts p
    JOIN users u ON p.user_id = u.id
    JOIN profiles pr ON u.id = pr.user_id
    JOIN post_stats ps ON p.id = ps.post_id
ORDER BY
    p.id DESC
LIMIT $2
`

type GetPaginatedPostsByUsernameParams struct {
	MyUserID   int64  `json:"my_user_id"`
	Limit      int32  `json:"limit"`
	Username   string `json:"username"`
	LastPostID int64  `json:"last_post_id"`
}

type GetPaginatedPostsByUsernameRow struct {
	PostID            int64              `json:"post_id"`
	OwnerID           int64              `json:"owner_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Content           *string            `json:"content"`
	LikeCount         int64              `json:"like_count"`
	CommentCount      int64              `json:"comment_count"`
	HasLiked          bool               `json:"has_liked"`
	ImageUids         []byte             `json:"image_uids"`
	OwnerUsername     string             `json:"owner_username"`
	OwnerName         string             `json:"owner_name"`
	OwnerProfileImage uuid.UUID          `json:"owner_profile_image"`
	OwnerIsFollowing  bool               `json:"owner_is_following"`
}

func (q *Queries) GetPaginatedPostsByUsername(ctx context.Context, arg GetPaginatedPostsByUsernameParams) ([]*GetPaginatedPostsByUsernameRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedPostsByUsername,
		arg.MyUserID,
		arg.Limit,
		arg.Username,
		arg.LastPostID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPaginatedPostsByUsernameRow
	for rows.Next() {
		var i GetPaginatedPostsByUsernameRow
		if err := rows.Scan(
			&i.PostID,
			&i.OwnerID,
			&i.CreatedAt,
			&i.Content,
			&i.LikeCount,
			&i.CommentCount,
			&i.HasLiked,
			&i.ImageUids,
			&i.OwnerUsername,
			&i.OwnerName,
			&i.OwnerProfileImage,
			&i.OwnerIsFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByPostID = `-- name: GetPostByPostID :one
WITH post_stats AS (
    SELECT
        p.id AS post_id,
        COUNT(DISTINCT pl.id) AS like_count,
        COUNT(DISTINCT c.id) AS comment_count,
        COALESCE(BOOL_OR(pl.user_id = $1), FALSE)::boolean AS has_liked,
        json_agg(DISTINCT pi.uid) FILTER (WHERE pi.uid IS NOT NULL) AS image_uids
    FROM
        posts p
        LEFT JOIN post_likes pl ON p.id = pl.post_id
        LEFT JOIN comments c ON p.id = c.post_id
        LEFT JOIN post_images pi ON p.id = pi.post_id
    WHERE
        p.id = $2
    GROUP BY
        p.id
)
SELECT
    p.id AS post_id,
    p.user_id AS owner_id,
    p.created_at AS created_at,
    p.content AS content,
    ps.like_count,
    ps.comment_count,
    ps.has_liked,
    ps.image_uids,
    u.username AS owner_username,
    pr.name AS owner_name,
    pr.profile_image AS owner_profile_image,
    EXISTS (
        SELECT
            1
        FROM
            followers
        WHERE
            followee_id = p.user_id
            AND follower_id = $1) AS owner_is_following
FROM
    posts p
    JOIN users u ON p.user_id = u.id
    JOIN profiles pr ON u.id = pr.user_id
    JOIN post_stats ps ON p.id = ps.post_id
`

type GetPostByPostIDParams struct {
	MyUserID int64 `json:"my_user_id"`
	PostID   int64 `json:"post_id"`
}

type GetPostByPostIDRow struct {
	PostID            int64              `json:"post_id"`
	OwnerID           int64              `json:"owner_id"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	Content           *string            `json:"content"`
	LikeCount         int64              `json:"like_count"`
	CommentCount      int64              `json:"comment_count"`
	HasLiked          bool               `json:"has_liked"`
	ImageUids         []byte             `json:"image_uids"`
	OwnerUsername     string             `json:"owner_username"`
	OwnerName         string             `json:"owner_name"`
	OwnerProfileImage uuid.UUID          `json:"owner_profile_image"`
	OwnerIsFollowing  bool               `json:"owner_is_following"`
}

func (q *Queries) GetPostByPostID(ctx context.Context, arg GetPostByPostIDParams) (*GetPostByPostIDRow, error) {
	row := q.db.QueryRow(ctx, getPostByPostID, arg.MyUserID, arg.PostID)
	var i GetPostByPostIDRow
	err := row.Scan(
		&i.PostID,
		&i.OwnerID,
		&i.CreatedAt,
		&i.Content,
		&i.LikeCount,
		&i.CommentCount,
		&i.HasLiked,
		&i.ImageUids,
		&i.OwnerUsername,
		&i.OwnerName,
		&i.OwnerProfileImage,
		&i.OwnerIsFollowing,
	)
	return &i, err
}
